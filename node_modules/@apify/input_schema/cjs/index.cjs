"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  inputSchema: () => schema_default,
  m: () => m,
  makeInputJsFieldsReadable: () => makeInputJsFieldsReadable,
  parseAjvError: () => parseAjvError,
  validateExistenceOfRequiredFields: () => validateExistenceOfRequiredFields,
  validateInputSchema: () => validateInputSchema,
  validateInputUsingValidator: () => validateInputUsingValidator
});
module.exports = __toCommonJS(index_exports);

// src/intl.ts
var intlStrings = {
  "inputSchema.validation.generic": "Field {rootName}.{fieldKey} {message}",
  "inputSchema.validation.required": "Field {rootName}.{fieldKey} is required",
  "inputSchema.validation.proxyRequired": "Field {rootName}.{fieldKey} is required. Please provide custom proxy URLs or use Apify Proxy.",
  "inputSchema.validation.requestListSourcesInvalid": "Items in {rootName}.{fieldKey} at positions [{invalidIndexes}] do not contain valid URLs",
  "inputSchema.validation.arrayKeysInvalid": 'Keys in {rootName}.{fieldKey} at positions [{invalidIndexes}] must match regular expression "{pattern}"',
  "inputSchema.validation.arrayValuesInvalid": 'Values in {rootName}.{fieldKey} at positions [{invalidIndexes}] must match regular expression "{pattern}"',
  "inputSchema.validation.objectKeysInvalid": 'Keys [{invalidKeys}] in {rootName}.{fieldKey} must match regular expression "{pattern}',
  "inputSchema.validation.objectValuesInvalid": 'Keys [{invalidKeys}] in {rootName}.{fieldKey} must have string value which matches regular expression "{pattern}"',
  "inputSchema.validation.additionalProperty": "Property {rootName}.{fieldKey} is not allowed.",
  "inputSchema.validation.proxyGroupsNotAvailable": "You currently do not have access to proxy groups: {groups}",
  "inputSchema.validation.customProxyInvalid": 'Proxy URL "{invalidUrl}" has invalid format, it must be socks[4|4a|5|5h]|http[s]://[username[:password]]@hostname:port.',
  "inputSchema.validation.apifyProxyCountryInvalid": 'Country code "{invalidCountry}" is invalid. Only ISO 3166-1 alpha-2 country codes are supported.',
  "inputSchema.validation.apifyProxyCountryWithoutApifyProxyForbidden": "The country for Apify Proxy can be specified only when using Apify Proxy.",
  "inputSchema.validation.noAvailableAutoProxy": "Currently you do not have access to any proxy group usable in automatic mode.",
  "inputSchema.validation.noMatchingDefinition": "Field schema.properties.{fieldKey} is not matching any input schema type definition. Please make sure that it's type is valid.",
  "inputSchema.validation.missingRequiredField": "Field schema.properties.{fieldKey} does not exist, but it is specified in schema.required. Either define the field or remove it from schema.required.",
  "inputSchema.validation.proxyGroupMustBeArrayOfStrings": "Field {rootName}.{fieldKey}.apifyProxyGroups must be an array of strings."
};
function m(stringId, variables) {
  let text = intlStrings[stringId];
  if (!text) return stringId;
  if (variables) {
    Object.keys(variables).forEach((variableName) => {
      text = text.split(`{${variableName}}`).join(variables[variableName]);
    });
  }
  return text;
}
__name(m, "m");

// src/schema.json
var schema_default = {
  title: "JSON schema of Apify Actor INPUT_SCHEMA.json",
  type: "object",
  properties: {
    $schema: {
      type: "string"
    },
    title: {
      type: "string"
    },
    schemaVersion: {
      type: "integer",
      minimum: 1,
      maximum: 1
    },
    description: {
      type: "string"
    },
    type: {
      enum: ["object"]
    },
    required: {
      type: "array",
      minItems: 0,
      items: { type: "string" },
      uniqueItems: true
    },
    additionalProperties: {
      type: "boolean"
    },
    properties: {
      type: "object",
      patternProperties: {
        "^": {
          oneOf: [
            { $ref: "#/definitions/stringProperty" },
            { $ref: "#/definitions/stringEnumProperty" },
            { $ref: "#/definitions/arrayProperty" },
            { $ref: "#/definitions/objectProperty" },
            { $ref: "#/definitions/integerProperty" },
            { $ref: "#/definitions/booleanProperty" },
            { $ref: "#/definitions/resourceProperty" },
            { $ref: "#/definitions/resourceArrayProperty" },
            { $ref: "#/definitions/anyProperty" }
          ]
        }
      }
    }
  },
  additionalProperties: false,
  required: ["title", "type", "properties", "schemaVersion"],
  definitions: {
    stringEnumProperty: {
      title: "Enum property",
      type: "object",
      additionalProperties: false,
      properties: {
        type: { enum: ["string"] },
        editor: { enum: ["select"] },
        title: { type: "string" },
        description: { type: "string" },
        default: { type: "string" },
        prefill: { type: "string" },
        example: { type: "string" },
        nullable: { type: "boolean" },
        sectionCaption: { type: "string" },
        sectionDescription: { type: "string" },
        enum: {
          type: "array",
          items: { type: "string" },
          minItems: 1,
          uniqueItems: true
        },
        enumTitles: {
          type: "array",
          items: { type: "string" },
          minItems: 1
        }
      },
      required: ["type", "title", "description", "enum"]
    },
    stringProperty: {
      title: "String property",
      type: "object",
      additionalProperties: true,
      properties: {
        type: { enum: ["string"] },
        title: { type: "string" },
        description: { type: "string" },
        nullable: { type: "boolean" },
        editor: { enum: ["javascript", "python", "textfield", "textarea", "datepicker", "hidden", "fileupload"] },
        isSecret: { type: "boolean" }
      },
      required: ["type", "title", "description", "editor"],
      if: {
        properties: {
          isSecret: {
            not: {
              const: true
            }
          }
        }
      },
      then: {
        if: {
          properties: {
            editor: { const: "datepicker" }
          }
        },
        then: {
          additionalProperties: false,
          properties: {
            type: { enum: ["string"] },
            title: { type: "string" },
            description: { type: "string" },
            default: { type: "string" },
            prefill: { type: "string" },
            example: { type: "string" },
            pattern: { type: "string" },
            nullable: { type: "boolean" },
            minLength: { type: "integer" },
            maxLength: { type: "integer" },
            editor: { enum: ["datepicker"] },
            sectionCaption: { type: "string" },
            sectionDescription: { type: "string" },
            dateType: { enum: ["absolute", "relative", "absoluteOrRelative"] }
          }
        },
        else: {
          additionalProperties: false,
          properties: {
            type: { enum: ["string"] },
            title: { type: "string" },
            description: { type: "string" },
            default: { type: "string" },
            prefill: { type: "string" },
            example: { type: "string" },
            pattern: { type: "string" },
            nullable: { type: "boolean" },
            minLength: { type: "integer" },
            maxLength: { type: "integer" },
            editor: { enum: ["javascript", "python", "textfield", "textarea", "hidden", "fileupload"] },
            isSecret: { enum: [false] },
            sectionCaption: { type: "string" },
            sectionDescription: { type: "string" }
          }
        }
      },
      else: {
        additionalProperties: false,
        properties: {
          type: { enum: ["string"] },
          title: { type: "string" },
          description: { type: "string" },
          example: { type: "string" },
          nullable: { type: "boolean" },
          editor: { enum: ["textfield", "textarea", "hidden"] },
          isSecret: { enum: [true] },
          sectionCaption: { type: "string" },
          sectionDescription: { type: "string" }
        }
      }
    },
    arrayProperty: {
      title: "Array property",
      type: "object",
      properties: {
        type: { enum: ["array"] },
        editor: { enum: ["json", "requestListSources", "pseudoUrls", "globs", "keyValue", "stringList", "select", "hidden"] }
      },
      additionalProperties: true,
      required: ["type", "title", "description", "editor"],
      if: {
        properties: {
          editor: { const: "select" }
        }
      },
      then: {
        additionalProperties: false,
        required: ["items"],
        properties: {
          type: { enum: ["array"] },
          editor: { enum: ["select"] },
          title: { type: "string" },
          description: { type: "string" },
          default: { type: "array" },
          prefill: { type: "array" },
          example: { type: "array" },
          nullable: { type: "boolean" },
          minItems: { type: "integer" },
          maxItems: { type: "integer" },
          uniqueItems: { type: "boolean" },
          sectionCaption: { type: "string" },
          sectionDescription: { type: "string" },
          items: {
            type: "object",
            additionalProperties: false,
            properties: {
              type: { enum: ["string"] },
              enum: {
                type: "array",
                items: { type: "string" },
                uniqueItems: true
              },
              enumTitles: {
                type: "array",
                items: { type: "string" }
              }
            },
            required: ["type", "enum"]
          }
        }
      },
      else: {
        additionalProperties: false,
        properties: {
          type: { enum: ["array"] },
          editor: { enum: ["json", "requestListSources", "pseudoUrls", "globs", "keyValue", "stringList", "hidden"] },
          title: { type: "string" },
          description: { type: "string" },
          default: { type: "array" },
          prefill: { type: "array" },
          example: { type: "array" },
          nullable: { type: "boolean" },
          minItems: { type: "integer" },
          maxItems: { type: "integer" },
          uniqueItems: { type: "boolean" },
          sectionCaption: { type: "string" },
          sectionDescription: { type: "string" },
          placeholderKey: { type: "string" },
          placeholderValue: { type: "string" },
          patternKey: { type: "string" },
          patternValue: { type: "string" }
        }
      }
    },
    objectProperty: {
      title: "Object property",
      type: "object",
      additionalProperties: false,
      properties: {
        type: { enum: ["object"] },
        title: { type: "string" },
        description: { type: "string" },
        default: { type: "object" },
        prefill: { type: "object" },
        example: { type: "object" },
        patternKey: { type: "string" },
        patternValue: { type: "string" },
        nullable: { type: "boolean" },
        minProperties: { type: "integer" },
        maxProperties: { type: "integer" },
        editor: { enum: ["json", "proxy", "hidden"] },
        sectionCaption: { type: "string" },
        sectionDescription: { type: "string" }
      },
      required: ["type", "title", "description", "editor"]
    },
    integerProperty: {
      title: "Integer property",
      type: "object",
      additionalProperties: false,
      properties: {
        type: { enum: ["integer"] },
        title: { type: "string" },
        description: { type: "string" },
        default: { type: "integer" },
        prefill: { type: "integer" },
        example: { type: "integer" },
        nullable: { type: "boolean" },
        minimum: { type: "integer" },
        maximum: { type: "integer" },
        unit: { type: "string" },
        editor: { enum: ["number", "hidden"] },
        sectionCaption: { type: "string" },
        sectionDescription: { type: "string" }
      },
      required: ["type", "title", "description"]
    },
    booleanProperty: {
      title: "Boolean property",
      type: "object",
      additionalProperties: false,
      properties: {
        type: { enum: ["boolean"] },
        title: { type: "string" },
        description: { type: "string" },
        default: { type: "boolean" },
        prefill: { type: "boolean" },
        example: { type: "boolean" },
        nullable: { type: "boolean" },
        groupCaption: { type: "string" },
        groupDescription: { type: "string" },
        editor: { enum: ["checkbox", "hidden"] },
        sectionCaption: { type: "string" },
        sectionDescription: { type: "string" }
      },
      required: ["type", "title", "description"]
    },
    resourceProperty: {
      title: "Resource property",
      type: "object",
      additionalProperties: false,
      properties: {
        type: { enum: ["string"] },
        title: { type: "string" },
        description: { type: "string" },
        editor: { enum: ["resourcePicker", "hidden"] },
        resourceType: { enum: ["dataset", "keyValueStore", "requestQueue"] },
        default: { type: "string" },
        prefill: { type: "string" },
        example: { type: "string" },
        nullable: { type: "boolean" },
        sectionCaption: { type: "string" },
        sectionDescription: { type: "string" }
      },
      required: ["type", "title", "description", "resourceType"]
    },
    resourceArrayProperty: {
      title: "Resource array property",
      type: "object",
      additionalProperties: false,
      properties: {
        type: { enum: ["array"] },
        title: { type: "string" },
        description: { type: "string" },
        editor: { enum: ["resourcePicker", "hidden"] },
        default: { type: "array" },
        prefill: { type: "array" },
        example: { type: "array" },
        nullable: { type: "boolean" },
        minItems: { type: "integer" },
        maxItems: { type: "integer" },
        uniqueItems: { type: "boolean" },
        resourceType: { enum: ["dataset", "keyValueStore", "requestQueue"] },
        sectionCaption: { type: "string" },
        sectionDescription: { type: "string" }
      },
      required: ["type", "title", "description", "resourceType"]
    },
    anyProperty: {
      title: "Any property",
      type: "object",
      additionalProperties: false,
      properties: {
        type: {
          type: ["array"],
          items: {
            type: "string",
            enum: ["object", "array", "string", "integer", "boolean"]
          },
          uniqueItems: true,
          additionalItems: false,
          minItems: 1
        },
        title: { type: "string" },
        description: { type: "string" },
        default: { type: ["object", "array", "string", "integer", "boolean"] },
        prefill: { type: ["object", "array", "string", "integer", "boolean"] },
        example: { type: ["object", "array", "string", "integer", "boolean"] },
        nullable: { type: "boolean" },
        editor: { enum: ["json", "hidden"] },
        sectionCaption: { type: "string" },
        sectionDescription: { type: "string" }
      },
      required: ["type", "title", "description", "editor"]
    }
  }
};

// src/input_schema.ts
var { definitions } = schema_default;
function parseAjvError(error, rootName, properties = {}, input = {}) {
  let fieldKey;
  let message;
  if (error.keyword === "type") {
    fieldKey = error.instancePath.split("/").pop();
    if (properties[fieldKey] && properties[fieldKey].nullable && input[fieldKey] === null) {
      return null;
    }
    message = m("inputSchema.validation.generic", { rootName, fieldKey, message: error.message });
  } else if (error.keyword === "required") {
    fieldKey = error.params.missingProperty;
    message = m("inputSchema.validation.required", { rootName, fieldKey });
  } else if (error.keyword === "additionalProperties") {
    fieldKey = error.params.additionalProperty;
    message = m("inputSchema.validation.additionalProperty", { rootName, fieldKey });
  } else if (error.keyword === "enum") {
    fieldKey = error.instancePath.split("/").pop();
    const errorMessage = `${error.message}: "${error.params.allowedValues.join('", "')}"`;
    message = m("inputSchema.validation.generic", { rootName, fieldKey, message: errorMessage });
  } else if (error.keyword === "const") {
    fieldKey = error.instancePath.split("/").pop();
    message = m("inputSchema.validation.generic", { rootName, fieldKey, message: error.message });
  } else {
    fieldKey = error.instancePath.split("/").pop();
    message = m("inputSchema.validation.generic", { rootName, fieldKey, message: error.message });
  }
  return { fieldKey, message };
}
__name(parseAjvError, "parseAjvError");
var validateAgainstSchemaOrThrow = /* @__PURE__ */ __name((validator, obj, inputSchema, rootName) => {
  if (validator.validate(inputSchema, obj)) return;
  const errorMessage = parseAjvError(validator.errors[0], rootName)?.message;
  throw new Error(`Input schema is not valid (${errorMessage})`);
}, "validateAgainstSchemaOrThrow");
function validateBasicStructure(validator, obj) {
  const schemaWithoutProperties = {
    ...schema_default,
    properties: { ...schema_default.properties, properties: { type: "object" } }
  };
  validateAgainstSchemaOrThrow(validator, obj, schemaWithoutProperties, "schema");
}
__name(validateBasicStructure, "validateBasicStructure");
function validateField(validator, fieldSchema, fieldKey) {
  const matchingDefinitions = Object.values(definitions).filter((definition2) => {
    return definition2.properties.type.enum ? definition2.properties.type.enum[0] === fieldSchema.type : Array.isArray(fieldSchema.type);
  });
  if (matchingDefinitions.length === 0) {
    const errorMessage = m("inputSchema.validation.noMatchingDefinition", { fieldKey });
    throw new Error(`Input schema is not valid (${errorMessage})`);
  }
  if (matchingDefinitions.length === 1) {
    validateAgainstSchemaOrThrow(validator, fieldSchema, matchingDefinitions[0], `schema.properties.${fieldKey}`);
    return;
  }
  if (fieldSchema.enum) {
    const definition2 = matchingDefinitions.filter((item) => !!item.properties.enum).pop();
    if (!definition2) throw new Error('Input schema validation failed to find "enum property" definition');
    validateAgainstSchemaOrThrow(validator, fieldSchema, definition2, `schema.properties.${fieldKey}.enum`);
    return;
  }
  if (fieldSchema.resourceType) {
    const definition2 = matchingDefinitions.filter((item) => !!item.properties.resourceType).pop();
    if (!definition2) throw new Error('Input schema validation failed to find "resource property" definition');
    validateAgainstSchemaOrThrow(validator, fieldSchema, definition2, `schema.properties.${fieldKey}`);
    return;
  }
  const definition = matchingDefinitions.filter((item) => !item.properties.enum && !item.properties.resourceType).pop();
  if (!definition) throw new Error('Input schema validation failed to find other than "enum property" definition');
  validateAgainstSchemaOrThrow(validator, fieldSchema, definition, `schema.properties.${fieldKey}`);
}
__name(validateField, "validateField");
function validateProperties(inputSchema, validator) {
  Object.entries(inputSchema.properties).forEach(
    ([fieldKey, fieldSchema]) => validateField(validator, fieldSchema, fieldKey)
  );
}
__name(validateProperties, "validateProperties");
function validateExistenceOfRequiredFields(inputSchema) {
  if (!inputSchema?.required?.length) return;
  Object.values(inputSchema?.required).forEach((fieldKey) => {
    if (inputSchema?.properties[fieldKey]) return;
    throw new Error(m("inputSchema.validation.missingRequiredField", { fieldKey }));
  });
}
__name(validateExistenceOfRequiredFields, "validateExistenceOfRequiredFields");
function validateInputSchema(validator, inputSchema) {
  validateBasicStructure(validator, inputSchema);
  validateProperties(inputSchema, validator);
  validateExistenceOfRequiredFields(inputSchema);
  validateAgainstSchemaOrThrow(validator, inputSchema, schema_default, "schema");
}
__name(validateInputSchema, "validateInputSchema");

// src/utilities.ts
var import_acorn_loose = require("acorn-loose");
var import_countries_list = require("countries-list");
var import_consts = require("@apify/consts");
function validateProxyField(fieldKey, value, isRequired = false, options = null) {
  const fieldErrors = [];
  if (isRequired) {
    if (value === null) return fieldErrors;
    if (!value) {
      const message = m("inputSchema.validation.required", { rootName: "input", fieldKey });
      fieldErrors.push(message);
      return fieldErrors;
    }
    const { useApifyProxy: useApifyProxy2, proxyUrls: proxyUrls2 } = value;
    if (!useApifyProxy2 && (!Array.isArray(proxyUrls2) || proxyUrls2.length === 0)) {
      fieldErrors.push(m("inputSchema.validation.proxyRequired", { rootName: "input", fieldKey }));
      return fieldErrors;
    }
  }
  if (!value) return fieldErrors;
  const { useApifyProxy, proxyUrls, apifyProxyGroups, apifyProxyCountry } = value;
  if (!useApifyProxy && Array.isArray(proxyUrls)) {
    let invalidUrl = false;
    proxyUrls.forEach((url) => {
      if (!import_consts.PROXY_URL_REGEX.test(url.trim())) invalidUrl = url.trim();
    });
    if (invalidUrl) {
      fieldErrors.push(m("inputSchema.validation.customProxyInvalid", { invalidUrl }));
    }
  }
  if (!useApifyProxy && apifyProxyCountry) {
    fieldErrors.push(m("inputSchema.validation.apifyProxyCountryWithoutApifyProxyForbidden"));
  }
  if (!useApifyProxy) return fieldErrors;
  if (apifyProxyCountry && !import_countries_list.countries[apifyProxyCountry]) {
    fieldErrors.push(m("inputSchema.validation.apifyProxyCountryInvalid", { invalidCountry: apifyProxyCountry }));
  }
  if (!options) return fieldErrors;
  const isStringsArray = /* @__PURE__ */ __name((array) => array.every((item) => typeof item === "string"), "isStringsArray");
  if (apifyProxyGroups && !(Array.isArray(apifyProxyGroups) && isStringsArray(apifyProxyGroups))) {
    fieldErrors.push(m("inputSchema.validation.proxyGroupMustBeArrayOfStrings", { rootName: "input", fieldKey }));
    return fieldErrors;
  }
  const selectedProxyGroups = apifyProxyGroups || [];
  if (!selectedProxyGroups.length && !options.hasAutoProxyGroups) {
    fieldErrors.push(m("inputSchema.validation.noAvailableAutoProxy"));
    return fieldErrors;
  }
  const availableProxyGroupsById = {};
  (options.availableProxyGroups || []).forEach((group) => {
    availableProxyGroupsById[group] = true;
  });
  const unavailableProxyGroups = selectedProxyGroups.filter((group) => !availableProxyGroupsById[group]);
  if (unavailableProxyGroups.length) {
    fieldErrors.push(m("inputSchema.validation.proxyGroupsNotAvailable", {
      rootName: "input",
      fieldKey,
      groups: unavailableProxyGroups.join(", ")
    }));
  }
  const blockedProxyGroupsById = options.disabledProxyGroups || {};
  selectedProxyGroups.filter((group) => blockedProxyGroupsById[group]).forEach((blockedGroup) => {
    fieldErrors.push(blockedProxyGroupsById[blockedGroup]);
  });
  return fieldErrors;
}
__name(validateProxyField, "validateProxyField");
function validateInputUsingValidator(validator, inputSchema, input, options = {}) {
  const isValid = validator(input);
  const { properties } = inputSchema;
  const required = inputSchema.required || [];
  let errors = [];
  if (!isValid) {
    errors = validator.errors.map((error) => parseAjvError(error, "input", properties, input)).filter((error) => !!error);
  }
  Object.keys(properties).forEach((property) => {
    const value = input[property];
    const { type, editor, patternKey, patternValue } = properties[property];
    const fieldErrors = [];
    if (type === "object" && editor === "proxy") {
      const proxyValidationErrors = validateProxyField(property, value, required.includes(property), options.proxy);
      proxyValidationErrors.forEach((error) => {
        fieldErrors.push(error);
      });
    }
    if (type === "array" && value && Array.isArray(value)) {
      if (editor === "requestListSources") {
        const invalidIndexes = [];
        value.forEach((item, index) => {
          if (!item) invalidIndexes.push(index);
          else if (!item.url && !item.requestsFromUrl) invalidIndexes.push(index);
          else if (item.url && !import_consts.URL_REGEX.test(item.url)) invalidIndexes.push(index);
          else if (item.requestsFromUrl && !import_consts.URL_REGEX.test(item.requestsFromUrl)) invalidIndexes.push(index);
        });
        if (invalidIndexes.length) {
          fieldErrors.push(m("inputSchema.validation.requestListSourcesInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidIndexes: invalidIndexes.join(",")
          }));
        }
      }
      if (patternKey && editor === "keyValue") {
        const check = new RegExp(patternKey);
        const invalidIndexes = [];
        value.forEach((item, index) => {
          if (!check.test(item.key)) invalidIndexes.push(index);
        });
        if (invalidIndexes.length) {
          fieldErrors.push(m("inputSchema.validation.arrayKeysInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidIndexes: invalidIndexes.join(","),
            pattern: patternKey
          }));
        }
      }
      if (patternValue && editor === "keyValue") {
        const check = new RegExp(patternValue);
        const invalidIndexes = [];
        value.forEach((item, index) => {
          if (!check.test(item.value)) invalidIndexes.push(index);
        });
        if (invalidIndexes.length) {
          fieldErrors.push(m("inputSchema.validation.arrayValuesInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidIndexes: invalidIndexes.join(","),
            pattern: patternValue
          }));
        }
      } else if (patternValue && editor === "stringList") {
        const check = new RegExp(patternValue);
        const invalidIndexes = [];
        value.forEach((item, index) => {
          if (!check.test(item)) invalidIndexes.push(index);
        });
        if (invalidIndexes.length) {
          fieldErrors.push(m("inputSchema.validation.arrayValuesInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidIndexes: invalidIndexes.join(","),
            pattern: patternValue
          }));
        }
      }
    }
    if (type === "object" && value) {
      if (patternKey) {
        const check = new RegExp(patternKey);
        const invalidKeys = [];
        Object.keys(value).forEach((key) => {
          if (!check.test(key)) invalidKeys.push(key);
        });
        if (invalidKeys.length) {
          fieldErrors.push(m("inputSchema.validation.objectKeysInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidKeys: invalidKeys.join(","),
            pattern: patternKey
          }));
        }
      }
      if (patternValue) {
        const check = new RegExp(patternValue);
        const invalidKeys = [];
        Object.keys(value).forEach((key) => {
          const propertyValue = value[key];
          if (typeof propertyValue !== "string" || !check.test(propertyValue)) invalidKeys.push(key);
        });
        if (invalidKeys.length) {
          fieldErrors.push(m("inputSchema.validation.objectValuesInvalid", {
            rootName: "input",
            fieldKey: property,
            invalidKeys: invalidKeys.join(","),
            pattern: patternValue
          }));
        }
      }
    }
    if (fieldErrors.length > 0) {
      const message = fieldErrors.join(", ");
      errors.push({ fieldKey: property, message });
    }
  });
  return errors;
}
__name(validateInputUsingValidator, "validateInputUsingValidator");
function makeInputJsFieldsReadable(json, jsFields, jsonSpacing = 4, globalSpacing = 0) {
  const parsedJson = JSON.parse(json);
  const replacements = {};
  jsFields.forEach((field) => {
    let maybeFunction = parsedJson[field];
    if (!maybeFunction || typeof maybeFunction !== "string") return;
    let ast;
    try {
      ast = (0, import_acorn_loose.parse)(maybeFunction, { ecmaVersion: "latest" });
    } catch {
      return;
    }
    const isMultiline = maybeFunction.includes("\n");
    const isSingleFunction = ast && ast.body.length === 1 && (ast.body[0].type === "FunctionDeclaration" || ast.body[0].type === "ExpressionStatement" && ast.body[0].expression.type === "ArrowFunctionExpression");
    if (!isSingleFunction && !isMultiline) return;
    const spaces = new Array(isSingleFunction ? jsonSpacing : jsonSpacing * 2).fill(" ").join("");
    maybeFunction = maybeFunction.split("\n").join(`
${spaces}`).trim();
    const replacementValue = isSingleFunction ? maybeFunction.replace(/[;]+$/g, "") : `\`${maybeFunction}\``;
    const replacementToken = `<<<REPLACEMENT_TOKEN:${Math.random()}>>>`;
    replacements[replacementToken] = replacementValue;
    parsedJson[field] = replacementToken;
  });
  let niceJson = JSON.stringify(parsedJson, null, jsonSpacing);
  Object.entries(replacements).forEach(([replacementToken, replacementValue]) => {
    niceJson = niceJson.replace(`"${replacementToken}"`, replacementValue);
  });
  const globalSpaces = new Array(globalSpacing).fill(" ").join("");
  niceJson = niceJson.split("\n").join(`
${globalSpaces}`);
  return niceJson;
}
__name(makeInputJsFieldsReadable, "makeInputJsFieldsReadable");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  inputSchema,
  m,
  makeInputJsFieldsReadable,
  parseAjvError,
  validateExistenceOfRequiredFields,
  validateInputSchema,
  validateInputUsingValidator
});
//# sourceMappingURL=index.cjs.map