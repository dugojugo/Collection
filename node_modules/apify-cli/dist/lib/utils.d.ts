import type { IncomingMessage } from 'node:http';
import { DurationFormatter as SapphireDurationFormatter } from '@sapphire/duration';
import { Timestamp } from '@sapphire/timestamp';
import { type ActorRun, ApifyClient, type ApifyClientOptions, type Build } from 'apify-client';
import { type Language } from './consts.js';
import type { AuthJSON } from './types.js';
export declare const Ajv: typeof import("ajv").default;
export declare const httpsGet: (url: string) => Promise<IncomingMessage>;
export declare const getLocalStorageDir: () => string;
export declare const getLocalKeyValueStorePath: (storeId?: string) => string;
export declare const getLocalDatasetPath: (storeId?: string) => string;
export declare const getLocalRequestQueuePath: (storeId?: string) => string;
/**
 * Returns object from auth file or empty object.
 */
export declare const getLocalUserInfo: () => Promise<AuthJSON>;
/**
 * Gets instance of ApifyClient for user otherwise throws error
 */
export declare const getLoggedClientOrThrow: () => Promise<ApifyClient>;
/**
 * Returns options for ApifyClient
 */
export declare const getApifyClientOptions: (token?: string, apiBaseUrl?: string) => ApifyClientOptions;
/**
 * Gets instance of ApifyClient for token or for params from global auth file.
 * NOTE: It refreshes global auth file each run
 * @param [token]
 */
export declare const getLoggedClient: (token?: string, apiBaseUrl?: string) => Promise<ApifyClient | null>;
export declare const getLocalConfigPath: (cwd: string) => string;
export declare const getJsonFileContent: <T = Record<string, unknown>>(filePath: string) => T | undefined;
export declare const getLocalConfig: (cwd: string) => Record<string, unknown> | undefined;
export declare const setLocalConfig: (localConfig: Record<string, unknown>, actDir?: string) => Promise<void>;
export declare const setLocalEnv: (actDir: string) => Promise<void>;
type CamelCase<S extends string> = S extends `${infer P1}-${infer P2}${infer P3}` | `${infer P1}_${infer P2}${infer P3}` ? `${Lowercase<P1>}${Uppercase<P2>}${CamelCase<Lowercase<P3>>}` : S;
export type KeysToCamelCase<T> = {
    [K in keyof T as CamelCase<string & K>]: T[K];
};
/**
 * Convert Object with kebab-case keys to camelCased keys
 */
export declare const argsToCamelCase: <T extends object>(object: T) => KeysToCamelCase<T>;
export declare const createSourceFiles: (paths: string[], cwd: string) => Promise<{
    name: string;
    format: "TEXT" | "BASE64";
    content: string;
}[]>;
/**
 * Get Actor local files, omit files defined in .gitignore and .git folder
 * All dot files(.file) and folders(.folder/) are included.
 */
export declare const getActorLocalFilePaths: (cwd?: string) => Promise<string[]>;
/**
 * Create zip file with all Actor files specified with pathsToZip
 */
export declare const createActZip: (zipName: string, pathsToZip: string[], cwd: string) => Promise<void>;
/**
 * Get Actor input from local store
 */
export declare const getLocalInput: (cwd: string) => {
    body: Buffer<ArrayBufferLike>;
    contentType: string | null;
    fileName: string;
} | undefined;
export declare const purgeDefaultQueue: () => Promise<void>;
export declare const purgeDefaultDataset: () => Promise<void>;
export declare const purgeDefaultKeyValueStore: () => Promise<void>;
export declare const outputJobLog: (job: ActorRun | Build, timeout?: number) => Promise<"no-logs" | "finished" | "timeouts" | undefined>;
/**
 * Returns npm command for current os
 * NOTE: For window we have to returns npm.cmd instead of npm, otherwise it doesn't work
 */
export declare const getNpmCmd: () => string;
/**
 * Returns true if apify storage is empty (expect INPUT.*)
 */
export declare const checkIfStorageIsEmpty: () => Promise<boolean>;
/**
 * Validates Actor name, if finds issue throws error.
 * @param actorName
 */
export declare const validateActorName: (actorName: string) => void;
export declare const sanitizeActorName: (actorName: string) => string;
export declare const isPythonVersionSupported: (installedPythonVersion: string) => boolean;
export declare const isNodeVersionSupported: (installedNodeVersion: string) => boolean;
export interface ActorLanguage {
    language: Language;
    languageVersion?: string;
}
export declare const downloadAndUnzip: ({ url, pathTo }: {
    url: string;
    pathTo: string;
}) => Promise<void>;
/**
 * Ensures the Apify directory exists, as well as nested folders (for tests)
 */
export declare const ensureApifyDirectory: (file: string) => void;
export declare const TimestampFormatter: Timestamp;
export declare const MultilineTimestampFormatter: Timestamp;
export declare const DateOnlyTimestampFormatter: Timestamp;
export declare const DurationFormatter: SapphireDurationFormatter;
export declare const ShortDurationFormatter: SapphireDurationFormatter;
/**
 * A "polyfill" for Object.groupBy
 */
export declare function objectGroupBy<K extends PropertyKey, T>(items: Iterable<T>, keySelector: (item: T, index: number) => K): Partial<Record<K, T[]>>;
export {};
//# sourceMappingURL=utils.d.ts.map