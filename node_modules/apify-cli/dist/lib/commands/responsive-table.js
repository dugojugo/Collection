import Table from 'cli-table3';
const compactModeChars = {
    'mid': '',
    'left-mid': '',
    'mid-mid': '',
    'right-mid': '',
    middle: ' ',
    'top-mid': '─',
    'bottom-mid': '─',
};
const compactModeCharsWithLineSeparator = {
    middle: ' ',
    'top-mid': '─',
    'bottom-mid': '─',
    top: '─',
    bottom: '─',
    'left-mid': '├',
    mid: '─',
    'mid-mid': '─',
    'right-mid': '┤',
};
const noSeparators = {
    left: '',
    right: '',
    mid: '',
    'bottom-left': '',
    'bottom-mid': '',
    'bottom-right': '',
    top: '',
    'top-left': '',
    'top-mid': '',
    'top-right': '',
    'left-mid': '',
    'mid-mid': '',
    'right-mid': '',
    bottom: '',
    middle: '  ',
};
export var CompactMode;
(function (CompactMode) {
    /**
     * Print the table as is
     */
    CompactMode[CompactMode["None"] = -1] = "None";
    /**
     * Minimized version of the table, with no separators between rows
     */
    CompactMode[CompactMode["VeryCompact"] = 0] = "VeryCompact";
    /**
     * A version of the compact table that looks akin to the web console (fewer separators, but with lines between rows)
     */
    CompactMode[CompactMode["WebLikeCompact"] = 1] = "WebLikeCompact";
    /**
     * Straight up no lines, just two spaces in the middle of columns
     */
    CompactMode[CompactMode["NoLines"] = 2] = "NoLines";
})(CompactMode || (CompactMode = {}));
const charMap = {
    [CompactMode.None]: undefined,
    [CompactMode.VeryCompact]: compactModeChars,
    [CompactMode.WebLikeCompact]: compactModeCharsWithLineSeparator,
    [CompactMode.NoLines]: noSeparators,
};
function generateHeaderColors(length) {
    return Array.from({ length }, () => 'cyan');
}
const terminalColumns = process.stdout.columns ?? 100;
/** @internal */
export const kSkipColumn = Symbol.for('@apify/cli:responsive-table:skip-column');
export class ResponsiveTable {
    options;
    rows = [];
    constructor(options) {
        this.options = options;
    }
    pushRow(item) {
        this.rows.push(item);
    }
    render(compactMode) {
        const rawHead = ResponsiveTable.isSmallTerminal() ? this.options.mandatoryColumns : this.options.allColumns;
        const headColors = generateHeaderColors(rawHead.length);
        const compact = compactMode === CompactMode.VeryCompact || compactMode === CompactMode.NoLines;
        const chars = charMap[compactMode];
        const colAligns = [];
        const head = [];
        const headKeys = [];
        for (const column of rawHead) {
            // Skip all hidden columns
            if (this.options.hiddenColumns?.includes(column)) {
                continue;
            }
            // If there's even one row that is set to have a skipped column value, skip it
            if (this.rows.some((row) => row[column] === kSkipColumn)) {
                continue;
            }
            // Column alignment
            colAligns.push(this.options.columnAlignments?.[column] || 'left');
            if (ResponsiveTable.isSmallTerminal()) {
                // Header titles
                head.push(this.options.breakpointOverrides?.small?.[column]?.label ?? column);
                // Actual key to get the value from
                headKeys.push(this.options.breakpointOverrides?.small?.[column]?.valueFrom ?? column);
            }
            else {
                // Always use full values
                head.push(column);
                headKeys.push(column);
            }
        }
        const table = new Table({
            head,
            style: {
                head: headColors,
                compact,
            },
            colAligns,
            chars,
        });
        for (const rowData of this.rows) {
            const row = headKeys.map((col) => rowData[col]);
            table.push(row);
        }
        return table.toString();
    }
    static isSmallTerminal() {
        return terminalColumns < 100;
    }
}
//# sourceMappingURL=responsive-table.js.map